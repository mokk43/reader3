<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <style>
        /* Layout */
        body { margin: 0; padding: 0; display: flex; height: 100vh; overflow: hidden; font-family: "Georgia", serif; background: #fff; }

        /* Sidebar */
        #sidebar { width: 300px; background: #f8f9fa; border-right: 1px solid #e9ecef; overflow-y: auto; padding: 20px; flex-shrink: 0; }
        .nav-header { display: flex; align-items: center; justify-content: space-between; font-family: -apple-system, sans-serif; font-weight: bold; color: #495057; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #dee2e6; }
        .nav-header .book-title { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .nav-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; font-family: -apple-system, sans-serif; font-size: 0.9em; }
        .nav-home { color: #3498db; text-decoration: none; }
        .nav-row select { padding: 4px 8px; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.9em; }

        /* TOC Tree */
        ul.toc-list { list-style: none; padding-left: 0; margin: 0; }
        ul.toc-list ul { padding-left: 20px; } /* Indent children */
        li.toc-item { margin-bottom: 8px; }
        a.toc-link { text-decoration: none; color: #495057; font-size: 0.95em; display: block; padding: 4px 0; line-height: 1.4; }
        a.toc-link:hover { color: #000; text-decoration: underline; }
        a.toc-link.active { color: #d63384; font-weight: bold; }

        /* Main Content */
        #main { flex-grow: 1; overflow-y: auto; position: relative; scroll-behavior: smooth; }
        .content-container { max-width: 700px; margin: 0 auto; padding: 60px 40px; line-height: 1.8; font-size: 1.15em; color: #212529; }

        /* Content Styling (Basic normalization for the book HTML) */
        .book-content img { max-width: 100%; height: auto; display: block; margin: 20px auto; }
        .book-content h1, .book-content h2, .book-content h3 { font-family: -apple-system, sans-serif; margin-top: 1.5em; color: #333; }
        .book-content p { margin-bottom: 1.5em; text-align: justify; }

        /* Navigation Footer */
        .chapter-nav { display: flex; justify-content: space-between; margin-top: 60px; padding-top: 20px; border-top: 1px solid #eee; font-family: -apple-system, sans-serif; }
        .nav-btn { text-decoration: none; color: #3498db; font-weight: bold; padding: 10px 20px; border: 1px solid #3498db; border-radius: 4px; transition: all 0.2s; }
        .nav-btn:hover { background: #3498db; color: white; }
        .nav-btn.disabled { opacity: 0.5; pointer-events: none; border-color: #ccc; color: #ccc; }

        /* Translation Status */
        .translation-status {
            font-size: 0.85em;
            font-weight: normal;
            color: #6c757d;
            white-space: nowrap;
        }
        .translation-status.loading { color: #856404; }
        .translation-status.error { color: #721c24; }
        .translation-status.success { color: #155724; }

        /* Translation blocks styling */
        .translated-block {
            margin: 0.75em 0 1.5em;
            color: #555;
            font-style: nor;
            padding: 0.5em 0;
            border-left: 3px solid #dee2e6;
            padding-left: 1em;
        }

        /* Loading placeholder for upcoming translation */
        .translation-loading {
            margin: 0.75em 0 1.5em;
            padding: 0.5em 1em;
            border-left: 3px solid #dee2e6;
            color: #999;
            font-style: normal;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .translation-loading::before {
            content: '';
            width: 14px;
            height: 14px;
            border: 2px solid #ccc;
            border-top-color: #666;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Mode: translated-only hides originals */
        body.translation-mode-translated .orig-block { display: none; }
        body.translation-mode-translated .translated-block,
        body.translation-mode-translated .translation-loading { 
            font-style: normal; 
            color: #212529;
            border-left: none;
            padding-left: 0;
        }
        body.translation-mode-translated .translation-loading { color: #999; font-style: italic; }

    </style>
</head>
<body>

    <!-- SIDEBAR -->
    <div id="sidebar">
        <div class="nav-row">
            <a href="/" class="nav-home">← Back to Library</a>
            <select id="translation-mode">
                <option value="original">原文</option>
                <option value="translated">中文</option>
                <option value="bilingual">双语</option>
            </select>
        </div>
        <div class="nav-header">
            <span class="book-title">{{ book.metadata.title }}</span>
            <span id="translation-status" class="translation-status idle">准备就绪</span>
        </div>

        <!-- Recursive Macro for TOC -->
        {% macro render_toc(items) %}
            <ul class="toc-list">
            {% for item in items %}
                <li class="toc-item">
                    {% set is_active = current_chapter.href == item.file_href %}
                    <a href="#" onclick="findAndGo('{{ item.file_href }}')"
                       class="toc-link {% if is_active %}active{% endif %}">
                        {{ item.title }}
                    </a>

                    {% if item.children %}
                        {{ render_toc(item.children) }}
                    {% endif %}
                </li>
            {% endfor %}
            </ul>
        {% endmacro %}

        {{ render_toc(book.toc) }}
    </div>

    <!-- MAIN CONTENT -->
    <div id="main">
        <div class="content-container">
            <div class="book-content" id="book-content">
                {{ current_chapter.content | safe }}
            </div>

            <div class="chapter-nav">
                {% if prev_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ prev_idx }}" class="nav-btn nav-prev">← Previous</a>
                {% else %}
                    <span class="nav-btn disabled">← Previous</span>
                {% endif %}

                <span style="color: #999; padding: 10px;">
                    Section {{ chapter_index + 1 }} of {{ book.spine|length }}
                </span>

                {% if next_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ next_idx }}" class="nav-btn nav-next">Next →</a>
                {% else %}
                    <span class="nav-btn disabled">Next →</span>
                {% endif %}
            </div>
        </div>
    </div>

    <script>
        // --- Constants ---
        const BOOK_ID = "{{ book_id }}";
        const CHAPTER_INDEX = {{ chapter_index }};
        const TRANSLATABLE_TAGS = ['P', 'H1', 'H2', 'H3', 'BLOCKQUOTE', 'LI'];

        // Helper to map TOC filenames to Spine Indices
        const spineMap = {
            {% for ch in book.spine %}
            "{{ ch.href }}": {{ ch.order }},
            {% endfor %}
        };

        // --- State ---
        let currentTranslations = [];  // sparse array: index -> translation text or null
        let translatingIndex = -1;     // which index is currently being translated
        let isTranslating = false;
        let targetLanguage = 'zh';
        let allElements = [];          // cached list of translatable elements
        const LOOKAHEAD = 10;          // translate visible + next 10

        // --- DOM Elements ---
        const tmodeSelect = document.getElementById('translation-mode');
        const statusDiv = document.getElementById('translation-status');
        const bookContent = document.getElementById('book-content');
        const mainContainer = document.getElementById('main');

        // --- Initialization ---
        async function init() {
            // Load saved mode from localStorage
            const urlParams = new URLSearchParams(window.location.search);
            const urlMode = urlParams.get('mode');
            const savedMode = urlMode || localStorage.getItem('reader3_tmode') || 'original';

            try {
                await loadConfig();
            } catch (e) {
                console.error('Failed to load translation config, using defaults.', e);
            }

            tmodeSelect.value = savedMode;

            // Apply initial mode
            applyMode(savedMode, false);

            // If mode is not 'original', try to load translations
            if (savedMode !== 'original') {
                checkAndLoadTranslations();
            }

            // Event listeners
            tmodeSelect.addEventListener('change', onModeChange);
            mainContainer.addEventListener('scroll', onScroll);

            // Update nav links to preserve query params
            updateNavLinks();
        }

        async function loadConfig() {
            const resp = await fetch('/api/translation/config');
            const config = await resp.json();
            targetLanguage = config.default_target_language || 'zh';
        }

        // --- Translation Logic ---
        function setStatus(msg, type) {
            statusDiv.textContent = msg;
            statusDiv.className = 'translation-status ' + type;
        }

        function onModeChange() {
            const mode = tmodeSelect.value;
            localStorage.setItem('reader3_tmode', mode);

            applyMode(mode, true);

            if (mode !== 'original') {
                checkAndLoadTranslations();
            } else {
                clearTranslations();
                setStatus('准备就绪', 'idle');
            }

            updateNavLinks();
        }

        function applyMode(mode, animate) {
            document.body.classList.remove('translation-mode-translated', 'translation-mode-bilingual');

            if (mode === 'translated') {
                document.body.classList.add('translation-mode-translated');
            } else if (mode === 'bilingual') {
                document.body.classList.add('translation-mode-bilingual');
            }
        }

        async function checkAndLoadTranslations() {
            const lang = targetLanguage;

            setStatus('检查翻译...', 'loading');

            // Cache elements
            allElements = getTranslatableElements();
            allElements.forEach(el => el.classList.add('orig-block'));

            try {
                const resp = await fetch(`/api/books/${BOOK_ID}/chapters/${CHAPTER_INDEX}/translation?tlang=${encodeURIComponent(lang)}`);
                const data = await resp.json();

                if (data.status === 'ready' || data.status === 'partial') {
                    // Load existing translations (may be partial)
                    currentTranslations = data.translations || [];
                    renderAllTranslations();
                    
                    // Check if all are translated
                    const done = currentTranslations.filter(t => t && t !== null).length;
                    if (done >= allElements.length) {
                        setStatus(`翻译完成 (${done}段)`, 'success');
                    } else {
                        setStatus(`已翻译 ${done}/${allElements.length}`, 'loading');
                        // Continue translating missing paragraphs
                        translateVisibleRange();
                    }
                } else if (data.status === 'missing') {
                    currentTranslations = [];
                    renderAllTranslations();
                    translateVisibleRange();
                } else if (data.status === 'error') {
                    setStatus('错误: ' + (data.message || '未知错误'), 'error');
                }
            } catch (e) {
                setStatus('检查翻译失败: ' + e.message, 'error');
            }
        }

        function onScroll() {
            if (tmodeSelect.value === 'original') return;
            translateVisibleRange();
        }

        function getVisibleRange() {
            // Find indices of visible + next 10 paragraphs
            const containerRect = mainContainer.getBoundingClientRect();
            let firstVisible = -1;
            let lastVisible = -1;

            for (let i = 0; i < allElements.length; i++) {
                const el = allElements[i];
                const rect = el.getBoundingClientRect();
                // Element is visible if it overlaps container viewport
                if (rect.bottom > containerRect.top && rect.top < containerRect.bottom) {
                    if (firstVisible === -1) firstVisible = i;
                    lastVisible = i;
                }
            }

            if (firstVisible === -1) {
                firstVisible = 0;
                lastVisible = 0;
            }

            // Include LOOKAHEAD paragraphs beyond last visible
            const endIndex = Math.min(lastVisible + LOOKAHEAD, allElements.length - 1);
            return { start: firstVisible, end: endIndex };
        }

        async function translateVisibleRange() {
            if (isTranslating) return;
            
            const { start, end } = getVisibleRange();
            
            // Find first untranslated paragraph in range
            let nextIdx = -1;
            for (let i = start; i <= end; i++) {
                if (!currentTranslations[i]) {
                    nextIdx = i;
                    break;
                }
            }
            
            if (nextIdx === -1) {
                // All in range are done, check total completion
                const done = currentTranslations.filter(t => t && t !== null).length;
                if (done >= allElements.length) {
                    setStatus(`翻译完成 (${done}段)`, 'success');
                }
                return;
            }
            
            // Show loading placeholder for this paragraph
            showLoadingPlaceholder(nextIdx);
            
            // Translate this paragraph
            await translateParagraph(nextIdx);
            
            // Continue with next in range
            translateVisibleRange();
        }

        function showLoadingPlaceholder(index) {
            if (index >= allElements.length) return;
            
            const el = allElements[index];
            
            // Remove any existing block at this position
            const existing = el.nextElementSibling;
            if (existing && (existing.classList.contains('translated-block') || existing.classList.contains('translation-loading'))) {
                existing.remove();
            }
            
            // Create loading placeholder
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'translation-loading';
            loadingDiv.textContent = '翻译中...';
            loadingDiv.dataset.index = index;
            
            el.parentNode.insertBefore(loadingDiv, el.nextSibling);
        }

        async function translateParagraph(index) {
            if (index >= allElements.length) return;
            
            isTranslating = true;
            translatingIndex = index;
            
            const done = currentTranslations.filter(t => t && t !== null).length;
            setStatus(`正在翻译第 ${index + 1}/${allElements.length} 段...`, 'loading');
            
            try {
                const resp = await fetch(`/api/books/${BOOK_ID}/chapters/${CHAPTER_INDEX}/translation/single`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        tlang: targetLanguage,
                        index: index
                    })
                });
                
                const data = await resp.json();
                
                if (data.status === 'ok') {
                    currentTranslations[index] = data.translation;
                    renderSingleTranslation(index, data.translation);
                    
                    const newDone = currentTranslations.filter(t => t && t !== null).length;
                    setStatus(`已翻译 ${newDone}/${allElements.length}`, 'loading');
                } else if (data.status === 'cached') {
                    currentTranslations[index] = data.translation;
                    renderSingleTranslation(index, data.translation);
                } else {
                    currentTranslations[index] = `[错误: ${data.message || '翻译失败'}]`;
                    renderSingleTranslation(index, currentTranslations[index]);
                }
            } catch (e) {
                currentTranslations[index] = `[错误: ${e.message}]`;
                renderSingleTranslation(index, currentTranslations[index]);
            }
            
            isTranslating = false;
            translatingIndex = -1;
        }

        // --- DOM Manipulation ---
        function getTranslatableElements() {
            // Get all translatable elements in document order
            // Same logic as Python: p, h1-h3, blockquote, li (but li only if no p inside)
            const elements = [];
            const all = bookContent.querySelectorAll('p, h1, h2, h3, blockquote, li');
            
            for (const el of all) {
                // For li: skip if it contains p descendants
                if (el.tagName === 'LI') {
                    if (el.querySelector('p')) continue;
                }
                
                // Skip empty elements
                if (!el.textContent.trim()) continue;
                
                elements.push(el);
            }
            
            return elements;
        }

        function renderSingleTranslation(index, text) {
            // Render a single translation at the given index
            if (index >= allElements.length) return;
            
            const el = allElements[index];
            
            // Remove loading placeholder or existing translation
            const existing = el.nextElementSibling;
            if (existing && (existing.classList.contains('translated-block') || existing.classList.contains('translation-loading'))) {
                existing.remove();
            }
            
            // Create translation block
            const transDiv = document.createElement('div');
            transDiv.className = 'translated-block';
            transDiv.textContent = text;
            transDiv.dataset.index = index;
            
            // Insert after original
            el.parentNode.insertBefore(transDiv, el.nextSibling);
        }

        function renderAllTranslations() {
            // Clear any existing translation/loading blocks
            bookContent.querySelectorAll('.translated-block, .translation-loading').forEach(el => el.remove());
            
            for (let i = 0; i < allElements.length; i++) {
                const el = allElements[i];
                el.classList.add('orig-block');
                
                if (currentTranslations[i]) {
                    const transDiv = document.createElement('div');
                    transDiv.className = 'translated-block';
                    transDiv.textContent = currentTranslations[i];
                    transDiv.dataset.index = i;
                    el.parentNode.insertBefore(transDiv, el.nextSibling);
                }
            }
        }

        function clearTranslations() {
            isTranslating = false;
            translatingIndex = -1;
            
            // Remove translated blocks and loading placeholders
            bookContent.querySelectorAll('.translated-block, .translation-loading').forEach(el => el.remove());
            
            // Remove orig-block class
            bookContent.querySelectorAll('.orig-block').forEach(el => el.classList.remove('orig-block'));
            
            currentTranslations = [];
            allElements = [];
        }

        // --- Navigation ---
        function findAndGo(filename) {
            const cleanFile = filename.split('#')[0];
            const idx = spineMap[cleanFile];

            if (idx !== undefined) {
                let url = "/read/" + BOOK_ID + "/" + idx;
                // Preserve translation params
                url += buildQueryString();
                window.location.href = url;
            } else {
                console.log("Could not find index for", filename);
            }
        }

        function buildQueryString() {
            const params = new URLSearchParams();
            const mode = tmodeSelect.value;
            if (mode !== 'original') params.set('mode', mode);
            
            const str = params.toString();
            return str ? '?' + str : '';
        }

        function updateNavLinks() {
            const qs = buildQueryString();
            
            document.querySelectorAll('.nav-prev, .nav-next').forEach(link => {
                if (link.href) {
                    const base = link.href.split('?')[0];
                    link.href = base + qs;
                }
            });
        }

        // --- Start ---
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
